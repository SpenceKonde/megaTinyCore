# Differences between megaTinyCore and stock core
We generally try to honor the Arduino API. Occasionally that is impractical. In some cases we are just explicitly stating what was true of the Arduino stock cores, but never acknowledged.

## Intended cases where behavior differs from official cores
While we generally make an effort to emulate the official Arduino core, there are a few cases where the decision was made to have different behavior to avoid compromising the overall functionality; the official core is disappointing on many levels. The following is a (hopefully nearly complete) list of these cases.

### I2C **Requires** External Pullup Resistors
Earlier versions of megaTinyCore, and possibly very early versions of DxCore enabled the internal pullup resistors on the I2C pins. This is no longer done automatically - they are not strong enough to meet the I2C specifications, and it is preferable for it to fail consistently without external ones than to work under simple conditions with the internal ones, yet fail under more demanding ones (more devices, longer wires, etc). However, as a testing aid, we supply Wire.`usePullups()` to turn on the weak internal pullups. If `usePullups()` ever fixes anything, you should install external pullups straight away. Our position is that whenever external pullups are not present, I2C is not expected to work. Remember that many modules include their own on-board pullups. For more information, including on the appropriate values for pullups, see the [Wire library documentation](../libraries/Wire/README.md)

### Digital I/O Functions Use Old Function Signatures
They return and expect `uint8_t` (byte) values, not `enum`s like the official megaavr board package does. Like classic AVR cores, constants like `LOW`, `HIGH`, etc are simply `#define`d to appropriate values. The use of `enum`s unfortunately broke many common Arduino programming idioms and existing code (granted, these idioms were poor programming practice - they're also incredibly widespread and convenient), increased flash usage, lowered performance and made optimization more challenging. The `enum` implementation made language design purists comfortable and provided error checking for newbies, because you couldn't pass anything that wasn't a PinState to a digital I/O function and would see that error if you accidentally got careless. Nevertheless, due to all the complaints, a compatibility layer was added to the official core, so all the old tricks would work again, it was just less performant. However, that got rid of what was probably the most compelling benefit by allowing the workarounds: the fact that it did generate an error for new users to train them away from common Arduino practices like passing 1 or 0 to `digitalWrite()`, `if(digitalRead(pin))` and the like. The choice of names of the `enum`s also had the perverse effect of making `PinMode(pin,OUTPUT)` (an obvious typo of `pinMode(pin,OUTPUT)`) into valid syntax (comma operator turns `pin,OUTPUT` into `OUTPUT`, and it returns a new `PinMode` of value `OUTPUT`...) and does nothing with it, instead of a syntax error (It took me over an hour to find the erroneous capitalization. That evening, I converted the digital I/O functions to the old signatures and removed the `enum`s). Anyway - the `enum`s are not present here, and they never will be; this is the case with [MegaCoreX](https://github.com/MCUdude/MegaCoreX) and [DxCore](https://github.com/SpenceKonde/DxCore) as well.

### Serial Does Not Manipulate Interrupt Priority
The official core for the (similar) megaAVR 0-Series parts, which megaTinyCore was based on, fiddles with the interrupt priority (bet you didn't know that!): It could under some circumstances set the serial DRE interrupt as lvl 1 pri, in order to make it run while in another ISR. This is all sorts of bad, even if implemented well. Of course, you know the one thing that you don't have to worry about with Arduino: the function was ill-conceived and even worse-implemented in the official core. megaTinyCore does not do this, saving several hundred bytes of flash in the process, and fixing at least one serious bug which could result in the microcontroller hanging if serial was being used inside an interrupt (which you shouldn't do) - there was at least one race condition, an I suspect one or more ways that aren't even race conditions, just bad code, can be found here. Now, writing to serial from an interrupt while the TX buffer is full will make it do what it does on classic AVR and block while directly calling the handlers until there is space in the buffer for all of the data waiting to be written or the buffer is empty (for `flush()`). At the same time as this was implemented, as part of the same effort, a bug possible when using the USART very close to it's maximum speed was addressed.

Later efforts to improve serial further increased it's performance and reduced the ram and flash footprint, particularly on parts with more than one serial port.

### Serial supports like, everything
Almost every weirdo hardware feature that the USART has, we expose. It is also able to receive up to 1 rx buffer full of data at the maximum baud rate, with the transmitting device sending continuously. Official megaAVR core can crash if you try to redline it, and classic AVRs can't get the baud rate on target even way way below the maximum, so there's really no comparison there.

### Serial options have different numeric values
The stock megaavr core used 12 bits across two bytes to store the configuration written to CTRLC... *to the 1 byte register, CTRLC*... Say you have a register, and 6 bits in it might be configured. Your users generate the value by ORing together constants you supply.

Do you:
1. Use the locations of the bits that get controlled, so the value passed to begin is the same as the value you have to write to ctrlc?
2. Make your own representation of it, which takes twice as many bits to represent, and is full of "reserved" positions for options that exist on parts that are not this AVR.

Hopefully I don't need to tell you which way they did it.

### The core *requires* compiling with -Os and LTO
LTO (link time optimization - it gets you about 15-20% smaller binaries that perform comparably to or better than normal ones) is required. This is set up automatically and is not a concern unless you are building in a very-not-arduino-like context - but if you try to disable it, everything will fall down around your ears. We make *very* heavy use of builtin functions like `__builtin_constant_p()` and similar in order to maximize the potential optimization, and some expanded API functions (most notably fast digital I/O) **require** LTO in order to work (in the fast digital I/O case, we need to be able to see that the thing that the user passed as a pin is constant. If we can't peer into other files to figure out if it's a constant, we can't do fast digital I/O.

Furthermore, -Os is required - we looked into offering -O3 - but we found that this caused a meticulously hand-implemented wall of intricate assembly that was implemented to eliminate duplication of code *to itself be duplicated* which in turn caused a compilation failure because it includes a named label.

The optimizer frankly isn't very good at doing either -Os or -O3, so you're missing less than you think. The compiler is very clever in some ways, but it's also very stupid in others. It's been too long since all the optimization passes were properly tuned and the avr-portion was up to date with the rest of it for the optimizer to really do a great job. The compiler appears to have peaked at version 4.3. 5.4 was worse (enough so that it broke pulsein, which is why it's supplied as asm). 6.x had some bad bug that we couldn't abide by - but it added support for LTO, which was a total gamechanger; They quickly went to 7.3, and that's still where we are. It's established wisdom that you want to use the oldest version of GCC that will do what you need, not the newest.

### SerialEvent Support is Dropped
This is deprecated on the official core and is, and always has been, a dreadful misfeature. Dropped as of 2.3.0.

### `digitalRead()` Does Not Turn Off PWM
On official cores, and most third party ones, the `digitalRead()` function turns off PWM when called on a pin. This behavior is not documented by the Arduino reference. This interferes with certain optimizations, makes `digitalRead()` take at least twice as long (likely much longer) as it needs to and generally makes little sense. Why should a "read" operation change the thing it's called on? We have a function that alters the pin it's called on: `digitalWrite()`. There does not seem to be a logically coherent reason for this and, insofar as Arduino is supposed to be an educational platform it makes simple demonstrations of what PWM is non-trivial (imagine setting a pin to output PWM, and then looking at the output by repeatedly reading the pin).

### `digitalWrite()` and `INPUT` Pins
Like the official "megaavr" core, calling `digitalWrite()` on a pin currently set `INPUT` will enable or disable the pullups as appropriate. `digitalWrite()` also supports "CHANGE" as an option; on the official core, this will turn the pullup on, regardless of which state the pin was previously in, instead of toggling the state of it. The state of the pullup is now set to match the value that the port output register was just set to.

This was done because of the huge volume of code that makes use of this behavior. We experimented with making pinMode() do the inverse for INPUT and INPUT_PULLUP, but this was removed by unanimous agreement by everyone in the discussion thread.

### `analogWrite()` and TCD0 Pins
Please see the above PWM feature description if using PWM on those pins and also using `digitalRead()` or direct port writes on the same pins (PIN_PC0, and PIN_PC1).

### TCA0 is Configured in Split Mode to Get 3 Additional PWM Pins
On the official "megaavr" board package, TCA0 is configured for "single mode" as a three-channel 16-bit timer (used to output 8-bit PWM). megaTinyCore always configures it for "Split mode" to get additional PWM outputs. See the datasheets for more information on the capabilities of TCA0. See [Taking over TCA0](https://github.com/SpenceKonde/megaTinyCore/blob/master/megaavr/extras/TakingOverTCA0.md) for information on reconfiguring it. One downside to this is that the compare channels do not support buffering, so changing the duty cycle can cause a glitch lasting up to one PWM cycle (generally under 1 ms).

### TCA0 TOP is 254, Not 255
0 is a count, so at 255, there are 256 steps, and 255 of those will generate PWM output - but since Arduino defines 0 as always off and 255 as always on, there are only 254 possible values that it will use. The result of this is that (I don't remember which) either `analogWrite(pin,254)` results in it being `LOW` 2/256's of the time, or `analogWrite(pin,1)` results in it being `HIGH` 2/256's of the time. On megaTinyCore, with 255 steps, 254 of which generate PWM, the hardware is configured to match the API, and this does not occur. As it happens, 255 also (mathematically) works out such that integer math gets exact results for `millis()` timing with both 16-MHz-derived and 20-MHz-derived clock speeds, which is relevant when TCA0 is used for `millis()` timing. The same thing is done for TCD0, though to 509, giving 510 steps. `analogWrite()` accounts for this, so that we can get the same output frequency while keeping the fastest synchronization prescaler for fastest synchronization between TCD0 and system clock domains.

#### Alert: This is different from DxCore
On DxCore, The TCD0 TOP value, by default, varies more widely (always (2^n * 255) - 1 - 254, 509, 1019, but not always 509 or 254) this option on the TCD can be changed at runtime as long as it is one of the values of that form. On mTC, due to flash constrains and less inspiring hardware capabilities we don't permit runtime changing of TCD0 TOP (but the simpler hardware makes it amenable for millis usage. )

### Type B Timers Not Used for PWM
On the official "megaavr" board package, as well as [DxCore](https://github.com/SpenceKonde/DxCore), the Type B timers are used to generate 8-bit PWM (one pin per timer). There are very few circumstances where this could increase the number of usable PWM pins. These timers are just too scarce and valuable on these parts. Being minimally useful for PWM, in short supply, and highly desirable for other purposes, support for using Type B timers for PWM was removed in order to save space that would otherwise be used initializing these timers for PWM and handling them in `analogWrite()` et. al. If a Type B timer is used for `millis()`, it is configured in a radically different way than the official core does it.

#### Alert: This is different from DxCore
On DxCore, the TCBs are used for PWM. They cannot do both PWM and millis at the same time.

## Very Low-level Differences Between Classic and Modern AVRs
There are two classes of significant low level architectural differences (aside from the vastly improved peripherals): the improved instruction set and the unified memory address space.

### Instruction Set (AVRe/AVRe+ vs AVRxt)
The classic AVR devices all use the venerable `AVRe` (ATtiny) or `AVRe+` (ATmega) instruction set (`AVRe+` differs from `AVRe` in that it has hardware multiplication and supports devices with more than 64k of flash). Modern AVR devices (with the exception of ones with minuscule flash and memory, such as the ATtiny10, which use the reduced core `AVRrc`) all use the latest iteration of the AVR instruction set, `AVRxt`. `AVRxt` has much in common with `AVRxm` (used in XMega parts) in terms of instruction timing - and in the few places where they differ, `AVRxt` is faster (SBIC, as well as LDD, and LD with pre-decrement, are all 1 clock slower on `AVRxm` vs `AVRxt` or `AVRe`), however `AVRxt` doesn't have the single-instruction-two-clock read-and-write instructions for memory access `LAT`, `LAC`, `LAS`, and `XCH`. The difference between subspecies of the AVR instruction set is unimportant for 99.9% of users - but if you happen to be working with hand-tuned assembly (or are using a library that does so, and are wondering why the timing is messed up), the changes are:
* Like AVRe+ and unlike AVRe (used in older tinyAVR), these do have the hardware multiplication.
* PUSH is 1 cycle vs 2 on classic AVR (POP is still 2)
* CBI and SBI are 1 cycle vs 2 on classic AVR
* LDS is 3 cycles vs 2 on classic AVR :disappointed: LD and LDD are - as always - two cycle instructions.
* RCALL and ICALL are 2 cycles vs 3 on classic AVR
* CALL is 3 cycles instead of 4 on classic AVR
* ST and STD is 1 cycle vs 2 on classic AVR (STS is still 2 - as any two word instruction must be)

As you can see, everything that involves writing to the SRAM is faster now; it would appear that any time it is writing to a location based on one of the pointer registers or the stack pointer, it's a single cycle. All the other improvements except `CBI` and `SBI` can be viewed as a consequence of that. Of course the variants of `CALL` are faster; they have to put the return address into the stack, that's a write to SRAM based on the stack pointer! I can't say I've ever felt like `LAT`, `LAC`, or `LAS` would be terribly useful as they are described in the instruction set manual. Those take a register and the address pointed to by the Z register, load the contents of the specified address and toggle, set or clear bits in that memory address the bits that were set to begin with in the register specified. **If that worked on special function registers, it would be a very useful instruction**, taking `PERIPHERAL.REGISTER |= SOME_BIT_bm;` from a 5 clock, non-atomic operation to a 2 clock atomic one! But according to the instruction set manual, they only work on sram anyway. Well, at least it's not as much of a loss. `XCH` is more obviously useful than the others, but being limited to SRAM, it's still not very interesting. So we didn't lose out that hard on that; and I doubt anyone will miss the DES encryption hardware that some xmegas had (from the days when DES was still considered useful) - we don't have the DES instruction either.

Note that the improvement to `PUSH` can make interrupts respond significantly faster (since they have to push the contents of registers onto the stack at the beginning of the ISR), though the corresponding `POP`s at the end aren't any faster. The change with `ST` impacted tinyNeoPixel. Prior to my realizing this, the library worked on SK6812 LEDs (which happened to be what I tested with) at 16/20 MHz, but not real WS2812's. However, once I discovered this, I was able to leverage it to use a single tinyNeoPixel library instead of a different one for each port like was needed with ATTinyCore (for 8 MHz, they need to use the single cycle `OUT` on classic AVRs to meet timing requirements, the two cycle `ST` was just too slow; hence the port had to be known at compile time, or there must be one copy of the routine for each port, an extravagance that the ATtiny parts cannot afford. But with single cycle `ST`, that issue vanished).

Oh, and one other instruction it doesn't have that (some) AVRxm parts have: The hardware `DES` encryption instruction - an instruction which is most effective at marking AVRxm as, ah, back from the time when `DES` was a big deal.

### Memory and Address Space Organization
On all modern AVRs with up to 48k of flash, both the flash and ram reside in the same address space - On tinyAVRs, the program memory starts at 0x8000, while on megaAVR 0-Series, it starts at 0x4000 to leave room for the 48k of flash that they can have, and on the Dx-Series parts with up to 32k of flash, they have the same layout as the tinyAVRs, while Dx-Series parts with 64k or 128k of flash have a 32k section of flash mapped at any given time (how to make sure variables go into this memory mapped flash has been described elsewhere in this document). There is another big and fundamental change to the layout of the address space as well: the registers are organized by peripheral. PORTA is assigned 0x400 to 0x41F. PORTB is the next 32 bytes, and so on - and the address space is far sparser - all the peripherals have multiple "reserved" registers that may or may not get functions added in the future. And each instance of a peripheral on a part that has multiple of them has the same layout. You can, say, pass a pointer to a TCB around without the functions that get it knowing which TCB they'll get, and then access the TCB registers through it. On classic AVRs the names of the registers were consistent, but their locations were all over the place, packed much more tightly, so that sort of trick isn't possible. This also means that the EEPROM (and USERROW) are part of this unified address space (on classic AVRs, reading was accomplished through special function registers, and was far more awkward).

#### The "I/O space" is Used Differently
The lowest 64 registers are special - you can read or write them with the `IN` or `OUT` instructions (hence, "I/O space") in a single clock cycle, *without* setting up a pointer to them as you would need to with `ST` or `LD`. The 32 "Low I/O registers" additionally have bit-level access instructions `CBI` and `SBI` to clear and set bits, and `SBIC`/`SBIS` to skip the next instruction if a certain bit is set or cleared. On all AVRxt parts released so far, the low I/O registers are used only for the VPORTs, up to VPORTG or the last port on the part, whichever comes first. This means `VPORTG.OUT |= 1 << n`, *where n is known at compile-time and constant*, is a 1 clock cycle atomic operation , while `VPORTG.OUT = 1 << n` (note the `=` in lieu of `|=`) takes two clock cycles. For the latter, the first cycle is to put the value to be stored into a register, and the second is to write it with an `OUT` instruction. The GPIOR0-3 registers occupying the last 4 bytes in the low I/O space (those are user-defined registers to use as you choose. We use GPIOR0 internally during startup to record reset cause, and store two types of warnings applicable to tuning). The reset flag register is always cleared very early in startup to prevent dirty resets, and when using a bootloader, so that it can honor bootloader entry conditions on next reset). No other part of this core touches those registers, and we only set GPIOR0; we never read it. So all can be used freely, as long as you remember that GPIOR0 is not empty when you enter setup, and contains the reset cause flags. Other Low I/O registers are not used by the hardware.

The 32 "high I/O registers" are used even less - they only contain the the stack pointer, `RAMPZ` on the 128k DA/DB parts, `SREG`, and `CCP` (Configuration Change Protection - where `_PROTECTED_WRITE()` does it's magic to let you write to protected registers. That's all - 5 out of 32 registers are used, the rest are "reserved". On classic AVRs, registers for assorted peripherals that the designers thought would be accessed often were put into the I/O space, so it was a disappointment that they didn't put an alias of any other registers there. I'd vote for the intflags registers to be aliased there

#### Working registers are *not* mapped to the data space, there is no SFR-to-IO address crap
On classic AVRs, the 32 working registers (r0-r31, not to be confused with SFR's, or special function registers, the more common use of "register") were mapped to the dataspace from 0x0000 to 0x001F, followed by the I/O space, starting at 0x20, with low I/O ending at 0x3F and high I/O ending at 0x5F. This means that address 0x0025 in the dataspace pointed to the same register as something that used I/O space addressing would get at address 0x05, and was the reason for things like SFR-to-IO macros in the past.

No more.

The working registers are not mapped to the data space. Mapping the working registers to the dataspace is madness. WTF good was it? If you're writing C, then you don't know what working register a variable is in, and if you're writing assembly you just look at the register; if that feature was useful to you you were doing something wrong. Now the I/O space 0x00 to 0x3F is mapped to data space 0x0000 to 0x003F.


## Direct Register Manipulation warning
If you are manually manipulating registers controlling a peripheral (except as specifically noted in relevant reference pages - some portions of the API are designed specifically permit this, particularly the PWM timers), *the stated behavior of API functions related to that by means obvious or obscure, can no longer be expected*. It may work like you hope, it may not - but it is not a bug if it doesn't work. (When you start poking at registers, you should usually be taking full control of that peripheral, and not using related api functions or libraries). Thus you should not assume that calling said API functions will not adversely impact the rest of your application. For example, if you "take over" TCA0, you should not expect that using `analogWrite()` - except on the two pins on the 20/24-pin parts controlled by TCD0 - will work for generating PWM. If you reconfigure TCA0 except as noted in Ref_Timers, without calling `takeOverTCA0`, both `analogWrite()` and `digitalWrite()` on a PWM pin may disrupt your changed configuration, or interfere with normal port operation.

This, strictly speaking, is not a difference from the stock core. It will also melt down if you fiddle with hardware registers arbitrarily. There are two big differences:
1. The stock core is not explicit about this fact, despite the fact that it's at least as bad.
2. The stock core exerts slightly more effort to picking up after other code defensively, but only slightly, and often at surprisingly high overhead.

# Library Compatibility
Please include information that uniquely identifies the library, as popular libraries have dozens of forks all over the internet, and it is often difficult to identify which is the "right one". Bonus points if you include a version number too - but I've given up on that!

## DxCore vs megaTinyCore
This page is linked to from the DxCore documentation as well, for the simple reason that the similarity of the underlying hardware is such that something that works with one will work with the other unless it's using specific features that are only present on one of the two (that is, it is a library for making use of a specific peripheral which was changed between those processors, which will always require library adjustment). It also, among other things, means that it is a recently written library with an author to complain to), or if it is very poorly written and checks for specific parts, rather than peripeheral types or things that are true for a whole host of parts (ie, testing for `#if defined(__ATtiny3216__) || defined(__ATtiny1614__)` - the two things the author tested on - when the exact same code might work on any modern AVR if they had instead tested `#if (__AVR_ARCH__>=102 && __AVR_ARCH__ <= 104)` - which picks up all modern AVRs with 64k of flash (102), 128k of flash (104) or 48k-or=less of flash (103 - the condition of `__AVR_ARCH__==103` is notable in that the flash is fully memory-mapped in these parts, and is not fully mapped for other Arduino-compatible AVRs; Now that we have reverted the changes to the F() macro, I don't think there are any issues specific those.

### A few plausible fault lines within the modern AVRs
Within the realm of modern AVRs (tinyAVR 0/1/2, megaAVR 0-series. Dx-series and Ex-series), there are only a limited number of plausible divding lines that are not just due to a lazy or sloppy author doing a check that doesn't catch all compatible parts.
* Almost all of these only ever apply to stuff that interacts directly with a peripheral:
* Cases where a library's function is to interact with a specific peripheral not present on all parts will never work on parts without that peripheral.
* Things that directly manipulate the event system will have trouble on either tinyAVR 0/1-series or everything else. The event system on 0/1-series is different (and significantly worse) than that on all other modern AVRs (which different from eachother only in numbers of channels quantity of peripherals to act as users and generators. These require two implementations - but you always need a bunch of part-specific stuff when using the event syste, Our attempt to provide an abstraction has yet to reach a point where I can recommend it, but that is the goal - an abstraction with consistent API for using the event system.
* PORTMUX registers are packed tighter (more peripherals per register in some cases) than elsewhere, and the names are different.
* tinyAVR 0/1-series and megaAVR 0-series have a few differences from the later models regarding timers and thier interaction with the event system.
  * They only had 1 event input for TCA0. More recent parts had 2.
  * Only TCA0 can count on event. On more recent parts, TCBs can as well.
* Things that manipulate the inner workings of the ADC will trip up, as each generation's ADC got subtle changes. tinyAVR 0/1 and megaAVR 0 are almost identical, Dx-series has 2 extra bits of resolutio, and the option for (kind of) differential measurements, but it otherwise is similar. The 2-series and Ex-series have an all new much more capable ADC, which behaves quite differently.
* Code written to interact with the RTC and developed on Dx-series or tinyAVR 2-series may not work on older parts, because of the severity of the silicon bugs there. Even basic operation requires use of (thankfully simple) workarounds. Those workarounds are nearly harmless (causing only very slight increase in powerdown sleep current) if used the parts without the bug, so moving forward isn't generally a problem
* Code that manipulates the system clock controller may pose challenges.
* Direct port manupulation counts as working with a peripheral (the PORT peripheral has it's own chapter, doesn't it?). All Dx-series parts get the multipin configuration for for settng PINnCTRL *on masse* and the DB and DD series (and likely any future opart with MVIO) has a TTL input level option, so you can tell them to have definitions of HIGH and LOW that don't depend on supply voltage.



<!-- markdownlint-disable-file MD034 -->
| Library      | Version | Library URL or reference                              | Status                               | Included w/ | Notes                                                     |
|--------------|---------|-------------------------------------------------------|--------------------------------------|-------------|-----------------------------------------------------------|
| tinyGPS++    |         | https://github.com/mikalhart/TinyGPSPlus              |                 Compiles and works   |             |                                                           |
| ~NeoGPS~     |         |                                                       |  Architecture warning, doesn't work  |             |                                                           |
| VEML6070     |         | Adafruit                                              |                 Compiles and works   |             |                                                           |
| MLX90614     |         | https://github.com/adafruit/Adafruit-MLX90614-Library |                 Compiles and works   |             |                                                           |
| BMP180       |         | Adafruit                                              |                 Compiles and works   |             |                                                           |
| BME280       |         | Adafruit                                              |                 Compiles and works   |             |                                                           |
| OneWireNg    |         | https://github.com/pstolarz/OneWireNg                 |                 Compiles and works   |             |                                                           |
| ~OneWire~    | Original| ~https://github.com/PaulStoffregen/OneWire~           |                   Does not compile   |             | Not compatible with modern AVRs other than the ATmega4809 |
| OneWire      | Forked  | https://github.com/SpenceKonde/OneWire                | full "megaavr" support added, works  |             | Works on all currently available "modern AVRs" and is expected to work on any future such parts with not more than 56 I/O pins (which would require a fundamental change in behavior of the hardware wrt. pin control). Tested PR submitted August 2020. No response from Paul. |
| ~Neopixel~   |         | ~Adafruit~                                            |                   Does not compile   |        Core | Use included tinyNeoPixel - Same API, adapted for these   |
| LED Backpack |   1.1.8 | https://github.com/adafruit/Adafruit_LED_Backpack     |                 Compiles and works   |             |                                                           |
| Tiny4kOLED   |   1.5.4 | https://github.com/datacute/Tiny4kOLED                |                 Compiles and works   |             | SSD1306, not just for tinyAVR - anything with Wire.h!     |
| U8x8 and U8g2 |2.28.10 | https://github.com/olikraus/u8g2                      | U8x8 works. People disgree on U8g2   |             | See: [this issue, esp. the end of it w/example code](https://github.com/SpenceKonde/megaTinyCore/discussions/454#discussioncomment-885742) |
| rc-switch    |         | https://github.com/sui77/rc-switch  (TX mode)         |                 Compiles and works   |             | A surprise. I don't expect RX will work                   |
| ~FAB-LED~    | Original| ~https://github.com/sonyhome/FAB_LED~                 |        Architecture is unsupported   |             | FAB-LED is a WS2812 w/out buffer library; impressive      |
| FAB-LED      | Forked  | https://github.com/SpenceKonde/FAB_LED                | I added support for "megaavr", works |             | No response to my PR to get my fix into his version :-/   |
| ~Servo~      |         | ~From library manager~ (the one included w/core works)|                      Compile error   |        Core | Use Servo_megaTinyCore if installed Servo via lib. mgr.   |
| TLC5947      |         | https://github.com/adafruit/Adafruit_TLC5947          |                 Compiles and works   |             | TLC5947 is a rather fancy LED driver.                     |
| MFRC522      | Frozen  | https://github.com/miguelbalboa/rfid                  |                 Compiles and works   |             | Long ago had issue relating to F(). This is the F()ing library that forced the return of the macro! |
| CAP1296      |         | https://github.com/mattThurstan/CAP1296               |                 Compiles and works   |             | Library needs cleanup - may not use correct ID by default, and prints stuff to Serial |
| MCP4725      |   2.0.0 | https://github.com/adafruit/Adafruit_MCP4725          |                 Compiles and works   |             | I2C 12-bit DAC                                            |
| MCP23017     |   2.0.0 | https://github.com/adafruit/Adafruit-MCP23017-Arduino-Library |         Compiles and works   |             | Also supports the MCP23008, which has half as many pins   |
| VL53L0X      |         | Pololu                                                |                 Compiles and works   |             | This and the one below are drastically different          |
| VL53L1X_ULD  |   1.2.2 | https://github.com/rneurink/VL53L1X_ULD               |                 Compiles and works   |   Lib. Mgr. |                                                           |

## Pre-compiled libraries
As of megaTinyCore 2.4.0, pre-compiled libraries (ie, those distributed with an archive file for each supported part) can be used. These sort of libraries have several significant disadvantages. First and foremost. the library must include a compiled .a file for the specific part being used. The libraries are also typically distributed without source code, so you cannot generate those files for the device you want to use. This is also the primary motivation for use of such libraries - to allow authors to distribute a library without letting anyone see their code, which may be licensed under proprietary terms. The libraries also trade off compile speed for binary size - but in the wrong direction: Compile speed increases because the library doesn't need to be compiled, but lacking the symbols normally left for the link-time optimizer, the linker cannot make it as small as it could if compiling from source. Finally, because the code is not available, you must rely upon the documentation provided by the library creators; and the commercial entities who adore proprietary licenses are far from immune to bad documentation. For these reasons, although they are supported, they are not recommended where alternatives are available.

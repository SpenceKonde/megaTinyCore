# PROGMEM and storing variables in flash
Unlike DxCore, all of these parts are __AVR_ARCH__ == 103. All parts if the flash are always mapped. All const variables will be automatically left in flash and accessed transparently. No special considerations are needed, and you dont have to worry about or use the F() macro or declaring things PROGMEM. The compiler (well, the linker) does it all for you!

If F() or PROGMEM is used however, it will behave as before, ie, read must be done with pgm_read_x, and you'll read garbage accessing it like a normal variable.  "how could this be? what is different?" you ask? The numeric value of a pointer to a constant variable declared without PROGMEM is the mapped location it can be accessed at in the data space - it is the address that is located at the program space, offset by 0x8000 (the mapped flash starts at 0x8000; this is what allows it to be treated like a normal variable). Declaring it PROGMEM doesn't add that 0x8000, so it's expressed as a location in the program space, not the data space, pgm_read_x functions work with addresses in the program space, using the lpm instruction.

Note that avr-gcc knows nothing about these different address spaces and isn't able to generate the required code to access code from program space addresses without prompting via the pgm_read macros (which are, in fact, just macros that point to little snippets of inline assembly that use the `lpm` instruction. While the raw speed of a single `lpm` instruction may at first glance appear comparable to `ld` accessing memory mapped flash (`ld` takes 2 clocks, plus "a minimum of 1 cycle ... added"`*` for accessing NVM, while `lpm` takes 3), that neglects to consider several key factors, none of which favor PROGMEM declared variables:

1. While both require setting up a pointer to the data in one of the pointer registers, `lpm` can only use the Z register, while `ld` can use X, Y, or Z, and `ldd` can use Y or Z, allowing the linker to avoid shuffling pointer addresses around in more cases.
2. Load with displacement (`ldd`) can reduce overhead dramatically when nearby addresses are accessed out of order.
3. Although the instruction set supports post-increment on `lpm`, it is only used when reading a multi-byte value from flash. Even if you are accessing consecutive addresses, `pgm_read_*` macros will not use the postincrement version of `lpm`

As a result of these issues (all of which are conseqences of the same root cause: the fact that the compiler has no understanding of the two address spaces), you will never get better performance from code where the `F()` macro is used than where it is not, nor will `const PROGMEM` variables ever outperform `const` variables - yet there is no penalty to using the more performant approach. Therefore, the F() macro should only be used for compatibility with libraries that require a `__flashStringHelper` passed to one of their provided functions, or where the same code is must work without modification on parts that do need the F() macro to tell it to store constant strings in flash. Variables should be declared `PROGMEM` only for the latter reason. For the same reasons, there are also no circumstances under which the PROGMEM or F() macro approach will result in smaller binaries, and they will often produce larger ones.

`*` Quoted from the AVR instruction set manual. The reader is referred to the NVMCTRL section of the datasheet for more information on this delay, however, in no modern AVR datasheet has information on this been contained therein. It is my understanding that the NVM access penalty is precisely 1 clock cycle for all types of load instruction (writing to NVM, of course, is a whole other ball game - and timing information on that is provided).

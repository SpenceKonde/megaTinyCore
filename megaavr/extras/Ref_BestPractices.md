# Best Practices checklist
Before deployment, be sure to run down this checklist for any circuit you design.

## Hardware Design
* 0.1uF cap between power and ground for every power pin on every IC unless the datasheet says otherwise.
* As specified in the datasheet of the parts, be sure to include all required decoupling caps, located between power and ground of every other IC, as close to it as possible. Even if they don't order you to, I put minimum of 0.1uF decoupling on any IC, as close to it's power pins as possible. Regulators tend to need larger capacitors than any other parts, and are sometimes very picky about what *kind* of cap. Be sure to pick caps within their specifications
* At least a few uF (I use 4.7) somewhere on the board for board level decoupling.
* If a regulator is used, ensure that capacitors match what the datasheet specs (part of why I love the LDD1117 - not only do they have well under 1V dropout under normal conditions, they also can use nice cheap ceramic capcacitors (some regs demand tants!). The output cap of the regulator, if it's ceramic or tant, counts towards board level decoupling.
* If using external clock, make sure it is located close to the chip. The same goes even moreso for a crystal and it's loading caps (though tinyAVR can't support crystals).
* Assuming this is a custom PCB, fill both layers with ground pours. Tie the two ground pours together with vias.
* To avoid delays, make sure you can get all the parts you're using. Order the parts you need ASAP if they seem to be in short supply (almost everything is now)
* Read the bloody errata, especially if on a DA, DB, or tiny 0/1. Those things have many relevant errata.
* Choose pins wisely. Make a list of how many pins you need with what functionality. Depending on your application pins 2 and 6 in each port may need to be valued differently, as they can respond to very brief interrupts and wake the chip on rising/failling because they are "fully async" - however, they are more vulnerable to electromagnetic noise for the same reason.
* Determining the crystal loading a priori can be very difficult - you need to knowe stray capacitances (which you almost certainly don't have a tool precise enough to measure) and the whole thing is full of black magic. On the classic AVRs, the crystals were power hogs, but it wasn't hard to make them work. Now, they may not be power hogs, but short of very expensive, high precision lab equipment (you need a FET probe for your scope, which I was told cost in the area of 1 grand, and even the soldering to get the adjustable caps on insstead of normal ones can be a job. People argue over what the rule of thumb is (if you ask around, you'll get three different answers, the largest at least 4x the smallest). I have been unable to determine why a given capacitor value (which by all accounts should not have worked, did, while all the other values (which were closer to what the formulas said) wouldn't oscillate). The only thing I can suggest is to get an assortment of small caps in the appropriate range of values, and then use trial and error to find a good working value (unless you have an incredibly well outfitted lab).
* If a voltage in excess of Vdd or below ground might ever be applied to any pin, you MUST take measures to limit the current and ensure that it stays within the range given in the datasheet. Often this can be achieved with a

## Software design
* Be sure to read the analog and digital reference pages, and any other reference document that sounds related to something you are workiing with. The implemenmtation of the API and extensions of it are documented in great detail, as are the ramifications of those details for the execution of user code.
* Use the PIN_Pxn notation to refer to pins (where X is the port letter, and n is the number of the pin within that port) - it makes it much easier to port code between parts, especially within the same family (since the peripherals are all on the same pins), and it makese discussions outside of the Arduino context (the only place the pin numbers exist) more useful.
* Don't override main unless you really understand the consequences, and and prepared to handle them. Most people are not. Among many issues you would encounter:
  * Even if you didn't disable millis, since you have overridden the function that calls the millis initializatuion function, delays will never expire and millis and micros will never increment. If you did disable millis? Guess what, the millis-disabled version of delay timing will be off too because it depends on the same assumption.
  * analogRead() will hang (waiting for the ADC to return a result, which it will never do as it's disabled).
  * If you try to work around the busted timekeeping with util/delay.h, you will discover that it's delays are the wrong length. They depend on the chip running at F_CPU. But you overrode the function that called the code to set the system clock speed (it's not done with fuses anymore - this is good, because it makes it much harder to brick the chip with wrong fuses).
  * A great many other core features will be broken.
  * Before overriding main(), read main.cpp and the init_* functions in wiring.c, as well as the [callback reference](Ref_Callbacks.md) which explains what callbacks that can be modified are not a good idea to modify. Main is one of them.
* Are you manually configuring a timer in a manner that is not explicitly permitted this core's timer documentation? You *must* call
* On modern tinyAVRs, and any other modern AVRs with 48k of flash or less, the flash is memory mapped. Const variables are automatically kept in flash! In other words, but can still be accessed like they were in RAM! NO MORE PROGMEM UNLESS A LIBRARY REQUIRES IT!
* You can do the same thing on 64k and 128k parts by putting the constants into the last 32k of flash by declaring them `PROGMEM_MAPPED`.

## Power considerations
There are a great many added complications to remember when you care about power consumption.
* Be aware of applicable errata and make sure that you won't be caught by them  (the DB one is particularly nasty).
* Floating pins, and pins that are in-between a high and a waste power. Supposedly this happened on classic AVRs too, and some people say it's not any worse now, but I am skeptical of that, as I've had projects that stayed alive in sleep mode for ages without taking such measures on classic AVRs, whereas a lot of the numbers that people complain about when they have floating pins on modern AVRs are considerably higher (I suspect that this may be related to the way that some pins Ensure that at least one of the following is true for every I/O pin:
    * It is set output, hence not floating.
    * It is set input_pullup, hence... not floating
    * It is connected to a digital signal hence again, not floating.
    * The port input buffer is disabled. This is the only correct configuration if the pin will have an external analog input on it.
  * I recommend doing this in a function called from Setup, so you can easily turn it off to keep from tripping over pins you forgot you were disabling and stuff like that during development, and then as you start turning to power consumption, then you can turn it on and. That way uncommenting a single function call is a small simple change. If it worked, other than power consumption, before making that change, and uncommenting the function call breaks something, you know that your unused + analog pin initialization routines is shitting on a pin you're actually using.
  * Only one of those things needs to be true.
  * **DO NOT set PIN_PA0 (the UPDI pin) to input disabled**! It is possible that the same issue applies to reset pins on parts with dedicated reset pins that can be used for I/O.
* On 2-series tinies, disable the ADC before sleeping.
* If you have been printing stuff, use Serial.flush() before sleeping to ensure it sends, and that a DRE interrupt doesn't wake you from sleep prematurely
* If you turn off power (with a fet or something) to an external device, make sure that none of it's I/O pins have a voltage applied, unless explicitly permitted by the datasheet. The vast majority of parts spec max voltage of Vdd +0.3. If Vdd = 0.0V, that means the voltages on all pins ought to be practically zero. Failing to verify this can lead to parts malfunctioning, increased power consumption and potentially even permanent hardware damaage!!

## Performance considerations
* Don't overclock unless you need to.
  * If you do, perform additional stability testing to make sure it's going to be reliable
* Avoid anything that use malloc, including most notably notably the String class.
* Interrupts should be written with great care. See [the Interrupt Reference](Ref_Interrupts.md).
  * attachInterrupt() is an abomination. I slapped it around and trimmed it's claws in 2.5.x, but it's still big, mean, and abominable. It wastes flash, the ISRs execute longer (sometimes many times longer) than a well-written ISR that did the same thing would. Try your best to avoid using it - if you need to dynamically change which interrupt is called at runtime, okay, yeah maybe you need something like that.
    * Attaching and Detaching interrupts is an antipattern.
    * Because of the avr-gcc ABI rules, every interrupt will spend about 50 clock cycles instead of 10-12 saving andrestoring registers (it has to save and restore all call used registers, because an ISR must save and restore all registers, and the compiler can't make assumptions about the function being called to relax that).
    * See [the Interrupt Reference](Ref_Interrupts.md).
  * With great skill, finesse and ISR_NAKED, incredibly performant interrupts are possible.
  * With skill, finesse, and competence, reasonably performant interrupts are possible.
  * With attachInterrupt, the battle is lost before it has even begun - performant interrupts are hopelessly out of reach. By the time code execution reaches the user code, no matter how efficient it is, it will have wasted enough time that an efficient, well written interrupt handler could have finished and returned control to the application. It presents multiple barriers: 1) it must handle the general case of an arbitrary pin triggering the interrupt, not just the pin you want to react to. The interrupt may not be enabled for any other pin on that port, but the compiler doesn't know anything about that, all it knows is the rules for volatile variables. Since special function registers are treated as volatile variables, and it is given no special insight into how the special function registers behave, it must see which pin triggered the interrupt and call that function. Even if only one pin ever has interrupts enabled, and only has it do one thing, it still has to do that checking. 2) It must then call a function using the standard ABI, which stipulates that any function called can shit all over a subset of registers (the call clobbbered registers - these are all upper registers except for r16/r17 and r28/r29). Because it's called by a pointer it cannot be inlined, even if the pointer is constant, always pointing to the same few instructions. 3. But because this is an ISR, All registers must be preserved, so because we call that function, it has to push and pop all call-clobbered registers, wherthere they get used or not.
    * The net effect of this is that any attached interrupt is going to be dog slow compared to an identical interrupot implemented directly
* Use digitalReadFast(), digitalWriteFast() and pinModeFast() when possible. If both the pin and the value is constant, they take only 1 clock to execute. the stock digital functions can takle dozens or even hundreds, and hundreds of bytes of flash.
* Be aware that C++ classes defang the optimizer, for the most part, and many optimizations that we might expect, in reality, ain't happening. Use caution when performance is critical.

## Part-sourcing considerations
* Some sort of electrical component is always in shortage. As of the early 2020's, there are few that are NOT in shortage. As I said above, be sure you can get the parts you want to use before getting PCBs made, and get those orders in early. I missed something that was in stock at digikey by less than a day. I put it in the cart, and then later, When I went to place the order, i saw that the item was now backordered. I could expect to get them around 2 years, assuming the schedule didn't slip (schedules always slip). If you think Microchip's 1 year backorder queue is bad, try to get a high-end PMIC chip from TI - 18-24 months. But since I hadn't ordered the board yet (or even designed the part in; I had looked at the godawful package I was going to have to draw in Eagle, and I dedicded I needed to do something more stimulating first, like cleaning the cat's litter box, or vacuuming the work room first. TI just loves these whackjob packages. I'm sure it can't help with their manufacturing throughput, which doesn't help with that long lead time bit....), I dug around some more and found a part from On-Semi that was less feature-rich - but I wasn't going to use those features - and the On-semi part cost less than half as much, had a standard footprint (albeit a tiny DFN6 with EP and an almost invisible orientation mark) instead of a HOTROD-10 (*"Hotrod 10? The hell is that?"* It's a TI PMIC package - picture a QFN-16. Squish the sides together so the two pads in each corner merge into one. Then take the middle pins on two opposite sides extend them towards the other pair leaving 4 normal pads on the other two sides, the 4 wierd-shaped corner pins (they touch the outside edge of the chip on two sides, but not at the tip of the corner...), and those two long pads right next to each other running the width of the chip (the "rods" of the "Hotrod", I guess); those two large pads are what carries the high current, though the part wasn't rated for an exotic current or anything). I used the On Semi part, and while they have been only intermittantly in stock, they have been obtainabl. Or they will be until may, because they're being discontinued with no comparable replacement this year (the TI part, costing several times more, is still backordered for years into the future).
  * Before I understood electronics, computers were magical - how could they achieve such complex and powerful behavior... Now, computers seem even more magical - Huh? I know what it does, but there have gotta be hundreds of different parts in a computer, and yet they managed to find all of them at the same time, none of them were discontinued during the design process without alternatives available, so they could put together not just one computer, but millions of them. I guess I need to buy some of them chips from on-semi, and I'd better make it fast.
* Prior to the covid-sideffect-part-shortages it was normal to have a "turnkey manufacturer" handle all the purchasing of parts. Most people I talk to are not quite doing that these days, because so many parts are hard to find for sale without long backorder delays. Parts which are critical for the project, yet single-sourced (such as AVR microcontrollers, which are (with the exception of those shoddily documented, almost-AVR LGT knockoffs, which are by no means a dropin replacement for anything) only made by Microchip), particularly if the company is having trouble meeting demand (like Microchip is), often having manufacturer lead times for relevant parts stretching well past a year. You can no longer rely on availability of parts being stable, so people are keeping private stockpiles of parts that they think they might need (which of course reinforces the shortage)
* Don't buy bare AVR chips from Aliexpress, especially modern AVRs. They're rarely sold there, and when they are, they are often fake or defective. Assembled boards (like pro mini and nano clones) are almost never DOA, though care is required, since there are "Arduino nano" boards that when you look more closely at the listing actually admit that they have an LGT chip instead of an ATmega (the LGT chips are a shitshow), and they also like making nano clones with 168's instead of 328's. The same goes for all IC's made by Western manufacturers.
* On the other hand, if you need a switch or button, or anything else with a mechanical component, you will probably be buying it on Aliexpress.
  * The search results on aliexpress are crappy. You do better by starting from a listing for something kinda like what you want, and scrolling down past the reviews, to where it shows related items that are not necessarily from the same seller. These will usually be more on target than your search results. In desperation, a google search specifying `site:aliexpress.com` and searching for your keywords. Often you do best with the image results (as long as you know what the thing you are hoping to get looks like).
* As long as the part you need is something for which there is a suitable "China Standard" version of (for example, 3x6mm SPST tact pushbuttonm?) you can find it from abundant suppliers for dirt cheap. The aforementioned switch? 1-2 cents each, twice that if you want the plastic button in crazy colors. For many simple elecronic and electromechanical components, there's a China Standard version. Try to use that - it will ensure easy second sourcing of the parts, lower costs, and reduce sourcing risk. These are typically made by many manufacturers, with subtle and rarely consequential veriartion.
  * Usually you can find the same part, from the official manufacturer instead of a clone producer, on digikey or similar, but if the item is a "china standard" it's price through those channels will be many times higher than the actual price one would pay to get it in a chinese manufacturuing facility. This is useful for getting the dimensions, even if you're using the clones (which everyone is)
  * There is rarely an advantage to not buying the cheap chinese production version - sometimes they are of lower quality, but the things that became china standards were rarely anything particularly well made.....
  * The clones are almost never better. They're liklier to be flimsier, less reliable, etc.
  * Except sometimes they are; usually asian brands copying other asian brands, but having better process capabililities.
* DIP and Rotary DIP-switch like switches are exorbitantly expensive. I do not understand why.
* Don't buy PVC insulated wire from china if you mind it being 4 AWG undersize. If that would be a problem, order wire insulated with FEP (which is also nicer wire). The vast majority of the wire on aliexpress et al is about 4 AWG undersized, if it's insulated in PVC (hence representing the cheap end of the spectrum).
* All "Arduino" boards on aliexpress are clones. Most work fine.

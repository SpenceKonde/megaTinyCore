# SPI for megaTinyCore
The SPI library implements all of the standard functionality described in the [Arduino SPI library reference](https://docs.arduino.cc/language-reference/en/functions/communication/spi/) - with the exception of the specific pins, of course!). Also, like all of the "big three" third-party cores for post-2016 AVR devices, this version of SPI.h supports the `swap()` and `pins()` methods to make use of the PORTMUX feature of the chips. Aside from those extensions, and a few changes to rarelty used, ill-conceived methods relating to interrupts, and unimplemented methods (likely intended for slave mode which was never implemented, for reasons discussed below), it behaves in the same way as the official one.

## Pins
| Pin Mapping   | Pins        | Parts           | Note                                                    |
|---------------|-------------|-----------------|---------------------------------------------------------|
| 8-pin parts   | PA1-3, PA0  | 8-pin only      | Swap not supported on 8-pin parts*                      |
| 0 (default)   | PA1-PA4     | 14+ pins        | Overlaps with very useful pins                          |
| 1 (alternate) | PC0-PC3     | 20+ pin         | Likely a better choice if using a part with this option |

Notes:
* The 8-pin parts, though they list an alternate pin mapping, it only appears to have MISO and MOSI - hence being somewhat less than useful. I'm not sure if the datasheet is just unclear and it does actually have an SCK output on another pin, whether it can be used by hacking things together with the event system or what the deal is (There is supposedly an SPI clock event generator). But the datasheet on the 0/1-series doesn't bother to include a table of the mux options in the PORTMUX chapter, so I couldn't really say. In any case, swapping the pins are not supported there.


## SPI pin swap methods
`SPI.swap(swap_level)` will set the the mapping to the specified pin swapping level. It will return true if this is a valid option for the part you're using, and false if it is not (you don't need to check this, but it may be useful during development). If an invalid option is specified, it will be set to SPI0 on the default pins.

`SPI.pins(MOSIpin, MISOpin, SCKpin);` or `SPI.pins(MOSIpin, MISOpin, SCKpin, SSpin);` can also be used - this will set the mapping to whichever mapping has the specified pins. MISO, MOSI, and SCK must be specified correctly; the SS pin is ignored (the option to specify it is provided only for backwards compatibility. It was decided that requiring it to be passed, when it's functionality would require a different library and is explicitly disabled, didn't really make much sense. If the pins passed are not a valid mapping option, it will return false and set the mapping to the default. This uses more flash than `SPI.swap();` - there is no advantage, and consequently SPI.swap() is recommended.

When `SPI.swap()` or `SPI.pins()` is called, assuming it was called with a valid option, the pin mapping requested is saved. When `SPI.begin()` is called, this stored value will specify changes to `PORTMUX.SPIROUTEA` and `PORTx` registers. Thus, if a non-default pin mapping is required, you must set it before before calling `SPI.begin()`. To change the pin mapping after `SPI.begin()` you must turn off SPI with`SPI.end()`, call `SPI.swap()` or `SPI.pins()` and then `SPI.begin()` again.

## Other differences between official cores and these

### Slave implementation
SPI.h does not support SPI slave mode, never has (on any Arduino platform to my knowledge), and never will. While a library to implement this is conceivable (SPI is in fact FAR simpler than I2C/TWI or USART) - there are a grand total of 5 registers, including the data register; implementing an SPI slave device can be done comparatively easy by directly configuring the registers - except for one little detail - and there has been very little interest on forums in SPI slave devices, and a great deal of interest in I2C slaves.

I believe the reason is precisely that one little detail: speed, or rather the comparative lack of it on the AVRs. SPI is run as speeds much higher than I2C, and has no mechanism for the slave to say "wait up, let me get data ready to send!". Between these two factors, the slave faces timing constraints that are often difficult or impossible to meet, or must be run at a SCK speed much lower than other slave devices would be run at. Consider that in master/slave mode, between the time that SS goes low, and 1 SCK period later, the slave must have loaded the register. It takes 6 system clocks *just to reach the ISR*, then a minimum of 4 for the prologue - likely more like 10 depending on the simplicity of your code. You'll likely need to load a pointer to the buffer (2 clocks to load the address), load the address from a global variable (3 clocks) and add to address (2 clocks, then load the next byte (2 more clocks) from the buffer. This is looking like 19 clocks. At that point with a 5 MHz clock, the master has already clocked out four zeros (assuming you're running at 20 MHz ) and you then have an extremely narrow window during which you can write that byte if you want it to go out on the next byte (this is why so many SPI devices involve "dummy bytes" being sent by the slave). Well what about buffered mode? Well it helps, as you now have at least 9 SCK periods to write the new data - but that still is a very short time. In the above example we might think we were fine. But then there's the cleanup as the interrupt exits: 1 clock to increment the address, 2 to store it, then an epilogue of minimum 7 clocks, more likely 10-15, then 4 clocks for the reti. That's 14-22 clocks more. And that's neglecting the fact that data FROM the master also comes in, and assuming the simplest possible SPI ISR.

I think the most realistic (ab)use of slave mode is using it as a shift register, where the clock is supplied from a timer and/or CCL to a pin, jumpered to SCK. Then shortly thereafter, (there are several ways of achieving that short delay without CPU intervention), another LUT configured as a latch could record the MISO pin state. Finally, that would be used by the remaining LUT to select between two waveforms being generated by a type A or type D timer; I this way a highly efficient implementation of a bespoke single wire protocol that didn't monopolize the CPU could be realized)

### UsingInterrupt() and the new attachInterrupt implementation
2.3.x introduced a new attachInterrupt implementation which increases flexibility and allows manually defined pin interrupts. It was soon reported that this was not compatible with SPI.h and a critical bug fix was released to correct it.

Unless the old attachInterrupt implementation is selected, `SPI.usingInterrupt(number)` will cause it to globally disable interrupts while in a transaction. This is not ideal, however *you should not have interrupts performing SPI transactions, period* - SPI transactions are not fast (though they're faster than I2C); interrupts should be fast. This is here for compatibility ONLY. The standard implementation of this does not map cleanly onto the new attachInterrupt(). Furthermore, the standard implementation has several logic gaps and race conditions which, together, could still result in the same sort of behavior it was aimed at preventing.
Similarly, `SPI.notUsingInterrupt(number)` will set it back to the normal mode. This is also not ideal, but we needed a timely fix and as I said, this functionality in any Arduino SPI.h library as supplied, merely approximated correct behavior. I'll come back to this at some point, but it is no longer an urgent - not least because *you should never use these functions*, because *you should not be using SPI from interrupts*! The one exception to this is the case where the number passed is NOT_AN_INTERRUPT (-1 or 255), in which case we match the old behavior and simply return.

### SPI.attachInterrupt and SPI.detachInterrupt are not available
These methods, as far as I can tell were penciled in for the official cores, but never actually implemented for official or third party AVR boards. hey were marked as something that should never be called in the version of SPI.h from the official core. There were traces of evidence that - maybe - on some third party core for a different, faster architecture may have had some API extension that was used to support SPI slave mode functionality. There was no sign of code that made use of them within the core or the wider internet. In fact, there was no sign of use of them on the wider internet - except for slave mode extensions for different architectures; I think I saw two of them, but none of them looked like they'd been finished (my guess is that they came to the conclusion I did above)

### SS (Slave Select) pin
On the all modern AVR parts, the SS pin can be configured to - when driven low -  switch the SPI peripheral into Slave mode, where it acts as an SPI slave (the same feature was present on the classic AVR parts, except now we can disable this). However, this library does not support slave mode (nor - as far as I am aware, has any official SPI library. It would seem that the Arduino userbase is much more enthusiastic about SPI master mode than slave mode; that is not particularly surprising. A basic TWI slave device has a lot of advantages, both in terms of how the code is written, and the timing constraints. SPI, on the other hand, has one major problem.

This core disables the SS pin when running in SPI master mode. This means that the "SS" pin can be used for whatever purpose you want - unlike classic AVRs, where the "slave-select" functionality of the SS pin could not be disabled (on classic AVRs, if that pin was input, and it went low - SPI was now in slave mode, whether you like it or not! And within Arduino circles "not" was pretty much universal, since SPI.h doesn't support slave mode.

## Note on terminology
At this point we are continuing to use the "master" and "slave" terminology for I2C and SPI devices; In some of it's reference material, Microchip has switcheed to "Host" and "Client", but this is reflected in only a small portion of their documents and is not reflected in register names, while countless thousands of documents, datasheets, guides, and code examples use "master" and "slave" (and while those words are distasteful, they are totally unambiguous, while host and client are not). Since clarity and avoidance of confusion is our goal we continue to use the old terminology, which is familiar to our users (particularly those who are not native english speakers and are likely not following politics in the western world). We continue to monitor the situation, and will switch when a replacement (hopefully something that is less ambiguous than "host" and "client") achieves more widespread use

# Wire (TWI/I2C)
All of these parts have at least one I2C/TWI module, and Wire.h provides the usual API - and then some.

## NEW in megaTinyCore 2.5.0/DxCore 1.4.0 - totally rewritten Wire library thanks to @MX682X
Should be 100% backwards compatible, use less flash, and have a new menu option to enable both master AND slave instead of the usual master OR slave. This uses the same pair of pins (this is termed "multimaster mode" in the 'biz). Enabling increases binary size, and allocates another buffer for data (out of RAM), and being the less common use case, we choose to default to the more efficient implementation in light the stringent constraints on these parts. Parts with "Dual Mode" have the option to use a separate pair of pins for the slave functionality.

## Pin Mappings (tinyAVR)
| Pincount | Default  | Alt (1-series only) |
|----------|----------|---------------------|
|   8-pin  | PA2, PA1 |                     |
| 14+ pin  | PB0, PB1 | PA2, PA1            |

## Pin Mappings (AVR Dx-series)
| Mapping | TWI0 M/S | TWI0 Dual | TWI1 M/S | TWI1 Dual |
|---------|----------|-----------|----------|-----------|
| Default | PA2, PA3 | PC2,  PC3 | PF2, PF3 | PB2,  PB3 |
| Alt1    | PA2, PA3 | PC6,  PC7 | PF2, PF3 | PB6,  PB7 |
| Alt2    | PC2, PC3 | PC6,  PC7 | PB2, PB3 | PB6,  PB7 |
| Alt3    | PA0, PA1 | PC2,  PC3 |    N/A   |    N/A    |

Notes:
* Alt3 is only available on AVR DD-series (and possibly EA-series).
* Alt1 is not available on parts which do not have PC6 and PC7 (for TWI0) or PB6, PB7 (for TWI1) because it would duplicate Default.
* But Alt2 is, since its's primary pins are different - though dual mode is not available if the pins aren't present.
* TWI1 only has the default mapping available on 32-pin parts. 48-pin and 64-pin parts are needed for dual mode (32-pin parts don't have a PORTB) and 64-pin parts needed for Alt1 (since PB6 and PB7 only exist on 64-pin parts). Alt2 is available on 48 and 64-pin parts only, for the same reason.
* In all cases the pins are listed as SCL, SDA.

Availability of pin mappings by pincount for AVR Dx-series
| Pin Pair | Function | 64 pin | 48 pin | 32 pin | 28 pin | 20 pin | 14 pin |
|----------|----------|--------|--------|--------|--------|--------|--------|
| PA0, PA1 | M/S only | n/a    | n/a    | For DD | For DD | Yes    | Yes    |
| PA2, PA3 | M/S only | Yes    | Yes    | Yes    | Yes    | Yes    | No     |
| PC2, PC3 | Either   | Yes    | Yes    | Yes    | Yes    | Yes    | Yes    |
| PC6, PC7 | Dualmode | Yes    | Yes    | No     | No     | No     | No     |
| PF2, PF3 | M/S only | Yes    | Yes    | Yes    | No     | No     | No     |
| PB2, PB3 | Either   | Yes    | Yes    | No     | No     | No     | No     |
| PB6, PB7 | Dualmode | Yes    | No     | No     | No     | No     | No     |

`Wire.swap(pin_set)` will set the the pin mapping to the specified set of pin.  See API reference below for details.

`Wire.pins(SDA pin, SCL pin)` - this will set the mapping to whichever mapping has the specified pins `SDA` and `SCL`. See API reference below for details. Only covered the master/slave pins, not the dual-mode pins. If you want the mode with the pins that can't do dual mode slave (PA2/3, or PF2/3) but with the alternate slave pins, you MUST use Wire.swap().

## Official specification of I2C
[From NXP, the current owner of the relevant IP](https://www.nxp.com/docs/en/user-guide/UM10204.pdf)

## Overview - I2C, what is it?
I2C (known by many names, see note at end) uses two pins, a clock (SCL) and data (SDA) for communication among two or more compatible devices. This is an open drain bus - external pullup resistors keep the two lines HIGH, and devices communicate by driving the pins low or releasing them. Data is clocked on the rising edge - this is important, as you will see.
In each transaction, one device, the "master" or "host" initiates communication by writing a "start condition" followed by clocking out a an 1 byte address. The "slave" or "client" device with that address (the address depends on the part; it may be fixed, software-configurable, set by an address pin state, etc - see the datasheet) will send a single bit in response (the ACK bit). The lowest bit of the address indicates whether the master is going to read or write. For a write, it will continue clocking out another byte when it gets the ACK bit, and this will repeat until either the slave refuses to ACK a byte (a NOACK) or the master is done sending. For a read, the after the address is ACK'ed, the master will generate the clock, and allow the slave to control the data line. The master will ack each byte until has read as many bytes as it is attempting to.

A start or stop condition is simply the data line being changed while the clock line is high; SDA H->L while SCL is high is a start, SDA L-> H is a stop. Otherwise, SDA is only asserted (driven low) or released when SCL is low. The "ACK" bit is generated by whichever device is receiving data, by driving SDA low after the 8th bit is received. A NACK is simply not doing so (so a device that "sends" a NACK, and a device that is not present at all, look the same to the master).

There is one more wrinkle. A slave device might be busy, and need some time to be able to receive data. I2C provides for that by permitting the slave to "stretch the clock" - On the ACK bit, a slave that will need more time to before it can handle the response will drive the SCL low before the master releases it. The slave then can process the incoming message, assert SDA to NACK, and then release the SCL, the master will see the rising edge, and that SDA was LOW, and recognize it as an ACK (or as a NACK if the slave did not assert SDA). Wire as slave, for examples, stretches the clock at the start of a read operation while the onRequest interrupt runs.

When I2C works, it is fantastically convenient. Lots of devices can be added, there is a huge selection of available parts, and while speeds are lower than SPI, they are almost always fast enough. It is easy to use, and the addressing allows hardware to be changed with minimal inconvenience. Because it's open drain, you can interface 3.3v and 5v devices easily. It's a wonderful interface. The Wire library lets you make your own I2C/Wire devices from Arduino, and everything is great. Until it's not.

One problem with I2C compared to other serial data buses is that because it has two wires, both of which are bidirectional, and because there is no external slave select pin (which can act as a failsafe to prevent one malfunctioning device from taking out the whole bus, usually either all devices on an I2C bus work, or nothing does. SPI requires more pins - but will almost never render the whole bus inoperative even when it's SS pin is not driven low. Even a completely hosed SPI device will usually let go of MISO when SS is raised. With I2C, the two most common failure modes are that one device doesn't respond, and the master waits forever (as opposed to SPI, which will typically clock in a bunch of zeros). Many I2C libraries will just wait forever for a response, and the code will be hung. The other, overlapping, most common problem is that a slave hangs while holding the clock and sometimes the data line low. At that point, and a power cycle is often needed to revive it. It also requires *external* pullup resistors, but works *just barely* with the internal ones, but often becomes unreliable when more devices are added.

## Pullups and logic levels
**The I2C interface is almost never within spec without external pullups.** If you aren't using breakout boards that have their own already installed, you need to add your own. Two pullups are needed, one connects SCL to Vcc, the other connects SDA to Vcc. If the parts run at different voltages, that is an added consideration - the pullups must go to the highest voltage that all parts tolerate, and that voltage must be high enough to be recognized as a HIGH by all parts. This can also require stronger pullups and lower speeds since the rise-time that matters is from the least favorable device's perspective for both minimum and maximum values of the pullups (usually the low voltage device's low input, and the higher voltage device's high threshold).

|  Wire Mode |    Frequency | Supported |  Pin drive |   Maximum Pullup Value (ohms and pF)   |  Minimum pullup value (total)   |
|------------|--------------|-----------|------------|----------------------------------------|---------------------------------|
| Standard   |   100,000 Hz |       Yes |  Under 3mA | R<sub>pu</sub>=1,180,000/C<sub>B</sub> | (V<sub>pu</sub> - 0.4V)  / 3 mA |
| Fast Mode  |   400,000 Hz |       Yes |  Under 3mA | R<sub>pu</sub>=  354,000/C<sub>B</sub> | (V<sub>pu</sub> - 0.4V)  / 3 mA |
| Fast Mode+ | 1,000,000 Hz |       Yes | Up to 20mA | R<sub>pu</sub>=  141,600/C<sub>B</sub> | (V<sub>pu</sub> - 0.2*Vdd/20 mA |

If you know the bus capacitance, you can calculate it the maximum value with that using these numbers from the AVR DB-series datasheet (the units have been multiplied through - if the bus capacitance is 50 pF (around 3-4 devices allowing for capacitance, in standard mode you would need pullups of less than 23.6k ohms, in Fast Mode you would need 7k pullups, and in Fast Mode Plus you would need 2.8k pullups). Unfortunately, you don't know the bus capacitance, and few of us have the equipment to measure it: It's the sum of the capacitance of the I2C pin on each device (which you know from the datasheet, usually), plus the stray capacitance from wires, PCBs, breadboard, etc. For the minimum, it's a simple application of Ohm's law and the V<sub>IHMAX</sub> for the I2C pins (often different from other I/O pins when acting as I2C), those numbers are what the spec guarantees. At 5V it would be 1.5k for Standard or Fast Mode, and 200 for Fast Mode Plus.

None of that accounts for the fact that wires, particularly long ones, have non-zero inductance. *I2C was designed to be used between ICs on a circuit board* and long wires can significantly degrade it's performance, requiring stronger pullups and/or lower speeds than you would otherwise require - note that while this lowers the maximum value, it is no help with the low end. Most people don't calculate the pullup values - we take an educated guess, and the window is wide enough that standard mode is rarely a problem. For small numbers of parts at standard speed, **4.7k is a good default value**, and *1.5-10k will generally be fine*. At higher frequencies, a smaller resistor might be required, see `Wire.setClock()` for the recommended values.

The internal pullups, however, are typically in the area of 30-50k. That may be okay for 2 devices at standard speed. Even 3-4 devices gets dicey, and wiring could sink even the 2-device case. By default, most classic AVR cores, including the official ones, turn on the internal pullups - giving a default configuration that would work under simple conditions. But as more devices were added, the bus would fail unpredictably, and the failures are often difficult to pin down and intermittent (one would typically wind up debugging a system right on the edge of failing). We don't enable them by default. If you want to use the pullups instead of using external ones, go ahead, calling `Wire.usePullups()` after choosing the pins will enable the internal pullups - but do so only with the knowledge that if I2C doesn't work later, the lack of external pullups is one of the most likely causes.

## Valid Addresses
Addresses are 7 bits - 8 bits are sent, and the least significant one indicates if it's a read or write operation. This leaves 128 addresses, however, some of them are "reserved", and have a special semantic meaning in I2C and I2C-compatible protocols.
|  Address  | binary format | Purpose                                                 |
|-----------|---------------|---------------------------------------------------------|
|      0x00 |     0b0000000 | General Call, followed by single byte command           |
|      0x01 |     0b0000001 | Reserved for compatibility w/CBUS protocol (obsolete)   |
|      0x02 |     0b0000010 | Reserved for compatibility w/other bus protocols        |
|      0x03 |     0b00001xx | Master Code for HS I2C  (AVRs do not support this mode) |
| 0x08-0x6F |               | Available                                               |
| 0x78-0x7B |     0b11110xx | Start of a 10-bit address (Wire supports as master)     |
| 0x7C-0x7F |     0b11111xx | Reserved for future use                                 |

The 10-bit addressing mode is not supported by the hardware; it could be implemented in software for slaves, but this would require modifications to the library, and there is little reason to implement this - uptake of 10-bit addressing has been spotty at best, and most I2C devices do not support it. Since the user has control of the slave address when using this library, and since virtually everything supports 7-bit addressing as master, it is implausible that it would become necessary, and has a non-zero cost (in terms of flash) to implement even if not used. On the master side, 10-bit addressing is simple: Those two bits are the most significant bits of the 10-bit address, and the first data byte sent is the other 8 bits; this can be used if you find yourself having to talk to something that requires 10-bit addresses.

## Extra addressing options in slave mode
In slave mode, it is possible to respond to the general call (0x00) address as well as it's own address (Thanks [@LordJakson](https://github.com/LordJakson)!). This is controlled by the optional second argument to Wire.begin(); If the argument is supplied and true, it will also react to general call commands.
These parts also support optionally having a second address, or masking (ignoring) some bits in the address. The optional third argument, if supplied, is passed unaltered to the TWI0.SADDRMASK register. If the low bit is 0, any bits set 1 will be ignored (masked off bits will be treated as matching). If the low bit is 1, it will instead act as a second address that the device can respond to. See the datasheet for more details. An everyday example of a part that does that sort of address masking is the 24-series of I2C EEPROMs (any 8-pin I2C EEPROM with 24 in the part number - many vendors make indistinguishable EEPROMs): When the size of the address of any cell within the EEPROM exceeds a multiple of 8 by 3 or less, it will use that many bits of the I2C address to address the memory; those bits are otherwise set by input pins. Hence with maximum options, the slave mode begin() call is:
```c
Wire.begin(uint8_t address, bool receive_broadcast, uint8_t second_address)
```

If the slave is configured to accept more than one address, it will often be critical to know which one it is responding to. Use `getIncomingAddress()` to see which address triggered it; This value is the internal representation (e.g., it is left-shifted by 1 place, and the low bit (indicating read/write) should be ignored)
```c
uint8_t addr = Wire.getIncomingAddress() << 1; // Returns incoming address in slave mode, currently as 8-bit address (left-shifted one place).
```

## Master/Slave mode
With the release of the enhanced Wire library we support operating as master and slave on the same pins (sometimes called a multi-master configuration). This functionality is optional, controlled by a Tools submenu. Select `Tools -> TWI (I2C/Wire.h) Options -> Master and Slave` from the tools menu to enable it. This uses more flash and more RAM (for the buffers - Wire requires several buffers, which are 32b each except at the extremes of supported flash sizes. All parts, including the tinyAVR line with the exception of the ATtiny402/202 support it when the master and slave functionality is on the same pair of pins. The full-size parts (the megaAVR 0-series like the ATmega4809, and the AVR Dx-series and upcoming Ex-series) *also* have an option to move the slave functionality to another pair of pins for increased flexibility. Thus, on parts without Dual Mode or where it is not in use, the single I2C bus will be connected to the AVR that is acting in both roles, one or more devices that act as master to control it, and one or more devices that controls - in addition to any other devices that are using I2C to communicate with the master(s) or slave(s). In such complicated configuration, the limits on communication imposed by the physics are the closest at hand - more devices = higher bus capacitance = slower rise and fall times and lower maximum data rates. Take particular care with voltage levels to ensure that the pullups are connected to a voltage compatible with all connected I2C devices.

Thankfully, assuming the hardware is able to handle the job, there is no special code needed, and working sketches can often be made through simple combination of the master code (including `Wire.begin()` with no arguments) and slave code (including `Wire.begin(address)` with one or more arguments, and either `onRequest()` or `onReceive()`). If either master or slave code needs to call `end()` without disturbing the other, there is an `endSlave()` and `endMaster`, as needed.

## Initialization order
There is a right and a wrong order to call the configuration functions. This order should work:
1. Wire.swapModule(&TWI1); (AVR DA/DB for special use cases)
2. Wire.swap(pinset) or Wire.pins(sclpin, sdapin)  (if needed for desired pins).
3. Wire.enableDualMode(fmplus_enable); (AVR Dx and megaAVR 0-series only, if needed)
4. Wire.usePullups() if you must...
5. Wire.begin() and/or Wire.begin(address, ...)
6. Wire.setClock(); (effects master mode only)

See the API reference below for more information.

## API reference
This is a full listing of methods provided for the TwoWire class (the class is named TwoWire, and Wire is an object of class TwoWire). Where they exist and behave the same way as documented in the Arduino Wire API reference they are simply listed. Where they do not, it is described here.

### The TwoWire class
Wire is an object of class TwoWire. The classic AVR Wire.h, like this library, has TwoWire as a subclass of Stream.
The official megaAVR 0-series core that megaTinyCore was based on in the distant past subclassed a new "HardwareI2C" class. Unfortunately, that imposed a shocking amount of overhead with no practical benefit. Code that relies on TwoWire being a subclass of HardwareI2C is virtually non-existent, and code that would benefit from an 500 bytes or so of flash is very common. Any library you encounter that works on classic AVRs (e.g., Uno) but complains of this different inheritance is straightforward to fix, likely as simple as searching the library files for "HardwareI2C" and changing it to "Stream".

### New Tools submenu: Wire Mode
DA and DB devices have all of these options. Others only have the first two
* Master or Slave (normal mode) - This uses the least flash and ram. At any given time Wire can be a master or a slave, but not both and you must call Wire.end(), and then the appropriate form of begin() for the mode you want to enable.
* Master And Slave - In this mode, an argumentless call to begin will start the master functionality, and a call to the form with one or more arguments will start the slave version. Both can run at the same time either using DualMode, or on the same pins (multi-master).
* Master or Slave x2 - In this mode, there is a Wire, and a Wire1 - corresponding to TWI0 and TWI peripherals.
* Master and Slave x2 - Combination of the two above options - Both Wire and Wire1 can each be both a master and a slave.


### Methods not present in official Arduino Wire library
This version adds several new methods to support additional functionality.
```c++
bool swap(uint8_t state = 1);
```
This will set the pin mapping to the selected pinset (see the table at top of this document). Only 1-series parts with more than 8 pins support this; on other parts, `Wire.swap()` will generate a compile error if a value known at compile time and not 0 is passed to it. On 1-series parts that do have an alternate pin mapping, a compile-time-known value that is not a 0 or 1 will similarly generate a compile error. An invalid value that is *not* known at compile time (in either case) will instead result in swap() returning false and selecting the default pins.

```c++
bool pins(uint8_t sda_pin, uint8_t scl_pin);
```
This will set the the pin mapping to the specified set of pins. If this is not a valid mapping option, it will return false and set the mapping to the default. This uses more flash than `Wire.swap()`; that method is preferred. As with `Wire.swap()`, this will generate a compile error if the pins are compile-time-known constants which are not a valid SDA/SCL pair, and pins not known at compile time will return false select the default pin mapping.

```c++
uint8_t getIncomingAddress();
```
This returns the last incoming address which most recently matched a slave's address, secondary address, or masked-address. Critical to using the general call alternate/masked address options. See the secondary and masked address examples.

```c++
uint8_t getBytesRead();
```
When called by an I2C/TWI slave, this returns the number of bytes that have been read by a master since the last time this was called.
To replicate the sort of auto-incrementing pointer that retains state across multiple consecutive reads from the master (without an intervening write, which under the register model that this is intended for will reset the pointer;
When this is called, it resets the internal count; be sure to retain it. It can be called from within or outside of either handlers. See the register_model() and register_model_master examples.
I had always wondered why Arduino sketches that implemented slave functionality used it like Serial-with-a-clock instead of Wire/TWI/I2C. Now I know. Without a function like this, that's all they CAN do!

This method is only useful when operating as a slave. See the register model example for a demonstration of how one might use it.

```c++
uint8_t slaveTransactionOpen();
```
This method, when called by the slave will return a value indicating whether there is currently an ongoing transfer. This is of particular use when the slave device is going to go to sleep but doesn't want to cut off a transaction in the middle. This could be polled until false prior to entering sleep. Remember - the onReceive handler is called at the end of a write, while the onRequest handler is called at the beginning of a read, and nothing is called at the end. This is only useful in slave mode. When operating as a master in Master or Slave mode, this simply returns 0.

```c++
endMaster();
```
This is analogous to `Wire.end()`, but only effects the master functionality, as the name implies.

```c++
endSlave();
```
This is analogous to `Wire.end()`, but only effects the slave functionality, as the name implies.

```c++
usePullups();
```
Unlike the official core, we do not automatically turn on the internal pullups, specifically because it can hide problems in simple tests - but not more complicated cases. Combined with the frustrating failure modes of I2C in general (not specific to this library) this can lead to a very challenging debugging experience if/when it does manifest as most I2C devices are added or longer wires are used, possibly dependent on orientation and spatial organization. Thus, we require that you read this paragraph and recognize that it could fail unpredictably before enabling the internal pullups. This is particularly problematic since Arduino users are accustomed to not having to think much about things like wire length and capacitance of wire; this is one of only a few cases where they often become relevant.

#### Additional New Methods not available on all parts
These new methods are available exclusively for part with certain specialized hardware; Most full-size parts support enableDualMode (but tinyAVR does not), while only the DA and DB-series parts have the second TWI interface that swapModule requires.
```c++
swapModule(TWI_t *twi_module);
```
This function is only available if the hardware has one module (DA or DB with 32+ pins); this allows you to swap the Wire object over to use TWI1, allowing the TWI1 pins to be used without creating both Wire and Wire1 - either because you need to use a library hardcoded to use Wire, not Wire1, or because you need to use the TWI0 pins. This must be called first, before `Wire.enableDualMode()` or `Wire.begin()`. Accepts `&TWI0` and `&TWI1` as arguments.

This method is available ONLY if both TWI0 and TWI1 are present on the device, but the tools -> Wire mode menu is not set to an option that creates Wire1. The point is to provide a facility to, without the overhead of both Wire modules, use the TWI1 pins instead of the TWI0 pins.

```c++
enableDualMode(bool fmp_enable);      // Moves the Slave to dedicated pins
```
This enables the "Dual Mode" which moves the slave functionality to a second pair of pins, such that there is a SCL/SDA pair for the master and an SCL/SDA pair for the slave. Some parameters (such as Fast Mode+ support) can be enabled separately for the slave. This must be called before `Wire.begin()` This is only available on megaAVR 0-series, and AVR Dx and Ex-series, not tinyAVR. The version of this document included with such parts will list the slave mode pinsets. This will generate an error if referenced on a tinyAVR.

### Standard methods and features significant differences
```c++
begin();
```
Calling `begin()` with no arguments starts the master. It does not start slave mode.

It does NOT turn on the pullups on any pin - unlike the standard version.

```c++
begin(uint8_t  address, bool receive_broadcast = 0, uint8_t second_address = 0);
```
This starts the slave Wire functionality. *It does not start master functionality - when both are enabled, begin() and begin(address) must be called*. The second and third arguments are optional.. The first argument simply specifies the slave address to listen on (like on standard `Wire.begin()`), the second argument enables receiving of general call addresses, and the third allows specification of either a second address, or a mask.

If receive_broadcast is true, the handler selected by `Wire.onReceive()` will be called when a "General Call" message is seen, containing the data or command included with it. General call commands are always writes, perhaps obviously (since more than one device attempting to respond would result in nothing but gibberish). My understanding is that general calls are always followed by a 1 byte command, and some or all of these values are reserved for certain purposes; I have not been successful at finding that list online, other that finding references to the I2C spec and that 0x00 is a software reset command. If not specified, this defaults to `false`; it must be specified if the third argument is used.

If second_address is supplied, two options can be used. In both cases a 7 bit address is supplied in the largest 7 bits (that is, leftshifted once from the traditional Arduino representation); it's function is controlled by the the least significant bit - if the LSB is 1, it's a second address matched in addition to the first. Otherwise, bits that are 1's are not masked off, and are not considered. Two helper macros are provided - these are meant for the sole purpose of code readability - the macro names are self explanatory.
```c++
#define WIRE_ALT_ADDRESS(alt_address) ((alt_address << 1) | 0x01)
#define WIRE_ADDRESS_MASK(mask) (mask << 1)
// The logic provided by the hardware is equivalent to
// if (received_address) == (address) ||  (received_address) == (address)
// and
// if ((received_address | mask) == (address | mask))
```
The third argument may be omitted if not used; it will default to 0, which is written unaltered to the hardware register; it will be treated as an address mask (the low bit is 0), but because it only masks bits that are 1's - it will not mask any bits (this functionality is always enabled - we just write a 0 if it's not specified - it has no further overhead as it is handled entirely by hardware after that.

When the second or third argument was used, `Wire.getIncomingAddress()` should be called during the interrupt handler or handlers; General call will only trigger the receive handler, while a masked/secondary address can take either a read or a write.

If (and only if) the Master and Slave option is selected in the Tools -> Wire mode, the Wire interface can be enabled for both master and slave. Even when Dual Mode is used, the correct option must still be selected to enable acting as both master and slave.

```c++
setClock(uint32_t);
```
The `setClock()` method has it's usual function. `Wire.setClock()` is not exact. The hardware clock generator monitors the SCL line, and begins the next pulse only after the pin has returned to HIGH and been there for a requisite amount of time. The length of these times, t<sub>high</sub> and t<sub>low</sub> are controlled by the `TWIn.MBAUD` register, which is what setClock() changes. But the period of each cycle is composed of 4 parts: t<sub>high</sub> +t<sub>fall</sub> + t<sub>low</sub> + <sub>fall</sub>. the high and low times are controlled by this register, and tFall is influenced by whether the part is set to "FM+ mode" (this drives the pin harder). As described above, the factor limiting the speed of I2C as the speed gets faster is the rise time, which is controlled solely by the total strength of all the pullups on the bus, and the capacitance of the bus. Since the baud generator adapts to electrical conditions, which are not known to the software, this clock setting would only match with one combination of pullup strength and bus capacitance, amd at the extremes, the difference in clock speed with the same baud rate set but different electrical conditions on the bus could be 50% or more. *This is preferable to the alternative approach of ignoring the electrical conditions, setting a fixed clock speed, and failing to transfer data under adverse electrical conditions*.

`Wire.setClock()`  must be called after `Wire.begin()`, and will briefly disable the TWI interface to make the necessary changes. It will handle setting the `FMPEN` bit to enable "Fast Mode Plus" for speeds in excess of what Fast Mode is capable of. Anything above 400 kHz will set the FMPEN bit to enable Fast Mode Plus (in dual mode, the slave pins must have this configured separately, since the slave needs to be warned ahead of time to expect Fast Mode Plus). Fast Mode and Standard are indistinguishable from the software's perspective.  Most parts these days support fast mode, and ones that support Fast Mode+ are common. You must be sure to run the bus at a speed compatible with all connected devices and for which the pullup is sufficient. See the discussion above for more about pullups. If not specified, the default is to approximate 100 kHz SCL clock speed. The speeds chosen by this method are more likely to be lower than you asked for than higher - this helps prevent accidentally using a higher clock speed than your other devices support. If it is problematic that the exact speed cannot be controlled tightly for I2C, the I2C bus is not the appropriate technology for your application. SPI allows the clock speed to be known with certainty at compile time (and allows much higher transfer speeds because it isn't limited by the rise-time of the open drain line)


|  Wire Mode | Maximum Frequency | Supported   |
|------------|-------------------|-------------|
| Standard   |        100,000 Hz | Yes         |
| Fast Mode  |        400,000 Hz | Yes         |
| Fast Mode+ |      1,000,000 Hz | Yes         |
| High Speed |      3,400,000 Hz | Unsupported |

Note that the resistor choice affects the SCL frequency that is generated by the AVR. This has something to do with how the TWI module is implemented in hardware. Generally, it does not impact the functionality of the bus though. The formula to calculate the frequency offers to compensate for the rise-time. To keep the library as small as possible, it was decided to measure the rise time for a couple of reasonable resistor choices, which you can find in the table below. Sticking to this values should result in accurate SCL frequencies as well as keep the rise-time inside the I2C specifications (usually).
Remember that the SCL frequency is generated by a divider, so at lower CPU frequencies, higher SCL frequencies will differ from the requested frequency more, then at higher CPU frequencies.

| expected Frequency | Recommended resistor |
|--------------------|----------------------|
|       < 400,000 Hz |             4.7k Ohm |
|       < 600,000 Hz |             2.2k Ohm |
|       >=600,000 Hz |             1.5k Ohm |

High Speed Mode is different animal altogether: FM+ more or less exhausted what could be achieved with a purely open drain bus, and of course, folks still demanded a faster bus. High Speed mode added a current source, and these devices usually separate HS from non-HS devices, using separate pins for each. No AVR device so far released supports HS I2C, and when such speeds are necessary, SPI is a better solution.

`Wire.setClock()` has been varying degrees of broken for most of the history of megaTinyCore. Users [@rneurink](https://github.com/rneurink) and [@MX682X](https://github.com/MX682X) made contributions and since 2.3.3 it has been reasonably close to correct. The old library was kind of a dumpster fire - this was far from the only problematic area of it. In a later version, the frequency accuracy was improved.

```c++
flush();
```


~A `flush()` method exists on all versions of Wire.h; indeed, `Stream` which it subclasses demands that - however very rarely is it actually implemented by anything other than Serial - (where there is a specific and very common reason use case) where one must clear the buffer in a specific way (by waiting for it to empty) before doing things like going to sleep or performing a software reset. Wire has rarely implemented this. In this case, it performs the functionality that the datasheets refer to as a "TWI_FLUSH" - this resets the internal state *of the master* - and at the Wire library level, the buffers are cleared; that command is apparently intended for error handling. The hardware keeps track of activity on the bus (as required by the protocol), but misbehaving devices can confuse the master - they might do something that the specification says a device will will not do, or generate electrical conditions that the master is unable to interpret in a useful way - pins not reaching the logic level thresholds, malformed data and which may in turn leave it confused as to whether the bus is available. It might be necessary to call in an attempt to recover from adverse events, which has historically been a challenge for the Wire library.~

```c++
uint8_t endTransmission(bool sendStop);
```
In 2.5.4/1.4.4 it was reported that the return value of this method did not match the API - it was returning a count of bytes written, which broke lots of existing code. This is now corrected. Values returned are a superset of the the stock version, covering three additional causes of errors. These are not expected to break existing code, since a 0 still indicates success, and it only reports some things with new codes that previously were considered "unknown errors", which should still be treated as errors by code.

| Value | Meaning                                                        | Standard |
|-------|----------------------------------------------------------------|----------|
|  0x00 | Success                                                        | Yes      |
|  0x01 | TX buffer overflow. Not used.                                  | Yes      |
|  0x02 | Timeout waiting for ack of address                             | Yes      |
|  0x03 | Timeout waiting for ack of data                                | Yes      |
|  0x04 | Unknown error                                                  | Yes      |
|  0x10 | Arbitration lost                                               | No       |
|  0x11 | Line held low or not pulled up                                 | No       |
|  0xFF | Bus in unknown state (begin() not called?)                     | No       |

In the case of a TX buffer overflow, when it gets to endTransmission, this looks the same as a full buffer, because write() didn't put the excess data into the buffer, and returned a number smaller than the number of bytes passed to it. I'm not sure how error code 1 could ever happen.

### Methods that have their standard behavior
The implementation isn't identical, but the behaviour is unchanged - or differ only in an irrelevant and implicitly convertible return or argument type (some versions of the official core have sizes returned as `size_t` for example; Nothing that any AVR will ever likely to involve single I2C-related function calls that act on 256 or more bytes; using a `uint8_t` helps to reduce flash size).
```c++
    void beginTransmission(uint8_t address);
    uint8_t requestFrom(uint8_t address, uint8_t quantity, uint8_t sendStop); // changed from size_t return type. Argument types differ, but are implicitly convertible without issues.
    size_t write(uint8_t data);
    int available();
    int read();
    int peek();
    void end();
```

### Remember when the handlers are called
```c++
    void onReceive(void (*)(int));
    void onRequest(void (*)(void));
```

#### Write Sequence
1. Master generates start condition.
2. Master clocks out the slave address with out read-bit set..
3. Slave detects and ACKs.
4. Master clocks out 1 or more data bytes as slave ACKs them.
5. Master generates a Stop Condition.
6. Slave fires onReceive handler passing it the number of bytes as an int16_t

#### Read Sequence
1. Master generates start condition.
2. Master clocks out the slave address with read-bit set
3. Slave detects and stretches the clock.
4. Slave fires onReceive handle.
5. In onReceive handler, stages all the data the master can read at this time (up to the size of the Wire Buffer) noted above.
6. Slave releases clock and ack's.
7. Master clocks in 1 while slave sends them, master ACKs each one before nacking when done and generating a stop condition.

## Why are there so many names for this protocol?
Wire, TWI (Two Wire Interface), Two Wire, IIC, I2C-compatible, I2C, I<sup>2</sup>C... The reason for this is that I2C (and the explicitly formatted version of it, I<sup>2</sup>C) are trademarked by Phillips (now NXP) which has historically been very litigious, and would go after manufacturers of parts that didn't pay license fees. So devices that could communicate with and which were I2C in all but name proliferated. The last patent expired a while ago, but they still hold the trademarks, so other manufacturers persist in using their names. The actual terms described in the specification claim to cover to all devices that "can" communicate over I2C, and make exception only for FPGAs, where the person programming them also was supposed to get a license. It seems that the litigation wars have cooled somewhat now, though I still would be mighty careful if I was designing microcontrollers. In any event, Atmel always called it TWI, and that tradition was not lost when Microchip purchased them. . So where did this name come from? IIC was apparently the inspiration: "Inter-Integrated Circuit".

Just don't get it confused with I2S (that's a specialized protocol for real-time transmission uncompressed digital audio - for example, it is (or was) often used in CD players between the disk reading circuitry and the DAC - as well as in professional audio equipment. I2S isn't supported by the AVR line - it's not a good match for the capabilities or intended use cases of AVR devices; it's for dedicated audio stuff, not general purpose microcontrollers). or I3C (a much faster superficially similar successor meant for much faster parts with more computational power - also not supported by AVR).

## Errata warning
All modern AVRs, since the release of the first tinyAVR 0/1-series, through the AVR DB-series, have always had a silicon bug relating to the TWI pins. When the TWI peripheral takes control of the SCL and SDA, it correctly controls their being an INPUT or OUTPUT - but it fails to also take over the output value... That means that if the PORTx.OUT bit is 1 for either of the pins, it would be trying to drive the line high instead of low, and the I2C bus would be non-functional. As of 2.2.6, we always clear those bits in begin(); this was not done on older versions. In any event, do not `digitalWrite()` either of the pins `HIGH` or set their `pinMode()` to `INPUT_PULLUP` after calling `Wire.begin()`. Calling them before that is pointless too, since they will be superseded by begin(). If you want to enabler the internal pullups, use Wire.usePullups.

## Known incompatible devices
For an unknown reason, the contactless IR-thermometer MLX90614 is not working out of the box with the new AVRs. We assume it has something to do with the implementation of the TWI module. A workaround is to set the clock frequency to a value between 110-125kHz.
